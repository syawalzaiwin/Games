<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Snake Game</title>
    <!-- Tailwind CSS CDN for basic styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS for the Snake Game */
        body {
            font-family: "Inter", sans-serif; /* Using Inter font */
            background-color: #1a202c; /* Dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Full viewport height */
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }

        .game-container {
            background-color: #2d3748; /* Slightly lighter dark background for container */
            border-radius: 1rem; /* Rounded corners */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5); /* Deep shadow */
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 90%; /* Max width for responsiveness */
            width: 500px; /* Base width */
            margin: 1rem; /* Margin around the container */
        }

        canvas {
            background-color: #1a202c; /* Darker background for canvas */
            border: 2px solid #4a5568; /* Border around the game area */
            border-radius: 0.5rem; /* Slightly rounded corners for canvas */
            display: block; /* Remove extra space below canvas */
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 1rem;
            color: #e2e8f0; /* Light text color */
            font-size: 1.25rem;
            font-weight: bold;
        }

        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            z-index: 100;
            display: none; /* Hidden by default */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7);
        }

        .message-box button {
            background-color: #4CAF50; /* Green button */
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 1rem;
            margin-top: 1rem;
            transition: background-color 0.3s ease;
        }

        .message-box button:hover {
            background-color: #45a049;
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            .game-container {
                padding: 1rem;
                width: 100%; /* Full width on smaller screens */
                margin: 0.5rem;
            }
            .game-info {
                font-size: 1rem;
            }
            .message-box {
                padding: 1.5rem;
                width: 80%;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-info">
            <span id="score">Score: 0</span>
            <span id="high-score">High Score: 0</span>
        </div>
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Message Box for Game Over/Start -->
    <div id="messageBox" class="message-box">
        <h2 id="messageTitle" class="text-3xl font-bold mb-4">Game Over!</h2>
        <p id="messageText" class="text-xl mb-6">Your final score: <span id="finalScore">0</span></p>
        <button id="restartButton">Play Again</button>
    </div>

    <script>
        // Get the canvas element and its 2D rendering context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Get score and high score display elements
        const scoreDisplay = document.getElementById('score');
        const highScoreDisplay = document.getElementById('high-score');
        // Get message box elements
        const messageBox = document.getElementById('messageBox');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');

        // Game constants
        const gridSize = 20; // Size of each segment of the snake and food
        let canvasSize = 400; // Initial canvas size (will be adjusted)
        let tileCountX, tileCountY; // Number of tiles in X and Y direction

        // Game variables
        let snake = [{ x: 10, y: 10 }]; // Initial snake position (array of segments)
        let food = {}; // Food position
        let dx = 0; // Direction in X (horizontal)
        let dy = 0; // Direction in Y (vertical)
        let score = 0;
        let highScore = localStorage.getItem('snakeHighScore') || 0; // Load high score from local storage
        let gameInterval; // Stores the interval ID for the game loop
        let gameSpeed = 150; // Initial game speed (milliseconds per frame)
        let isGameOver = false;
        let changingDirection = false; // Flag to prevent rapid direction changes

        // Touch event variables
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;

        /**
         * Initializes the game board size based on the window size.
         * Ensures the canvas is a square and fits within the screen.
         */
        function initializeCanvasSize() {
            const maxDimension = Math.min(window.innerWidth, window.innerHeight) * 0.8; // 80% of smaller dimension
            canvasSize = Math.max(300, Math.min(400, maxDimension)); // Keep between 300 and 400
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            tileCountX = canvas.width / gridSize;
            tileCountY = canvas.height / gridSize;
            // Recalculate snake and food positions if they are out of bounds
            snake.forEach(segment => {
                segment.x = Math.min(segment.x, tileCountX - 1);
                segment.y = Math.min(segment.y, tileCountY - 1);
            });
            if (food.x !== undefined) {
                food.x = Math.min(food.x, tileCountX - 1);
                food.y = Math.min(food.y, tileCountY - 1);
            }
        }

        /**
         * Generates a random position for the food, ensuring it's not on the snake.
         */
        function generateFood() {
            let newFoodX, newFoodY;
            let collisionWithSnake;
            do {
                // Generate random coordinates within the canvas grid
                newFoodX = Math.floor(Math.random() * tileCountX);
                newFoodY = Math.floor(Math.random() * tileCountY);
                collisionWithSnake = false;
                // Check if the new food position collides with any part of the snake
                for (let i = 0; i < snake.length; i++) {
                    if (snake[i].x === newFoodX && snake[i].y === newFoodY) {
                        collisionWithSnake = true;
                        break; // Exit loop if collision found
                    }
                }
            } while (collisionWithSnake); // Keep generating until no collision
            food = { x: newFoodX, y: newFoodY };
        }

        /**
         * Draws a single segment of the snake or food.
         * @param {number} x - X coordinate of the segment.
         * @param {number} y - Y coordinate of the segment.
         * @param {string} color - Color of the segment.
         */
        function drawSegment(x, y, color) {
            ctx.fillStyle = color;
            // Draw a rounded rectangle for a smoother look
            const radius = gridSize / 4; // Adjust radius for roundness
            ctx.beginPath();
            ctx.moveTo(x * gridSize + radius, y * gridSize);
            ctx.lineTo(x * gridSize + gridSize - radius, y * gridSize);
            ctx.arcTo(x * gridSize + gridSize, y * gridSize, x * gridSize + gridSize, y * gridSize + radius, radius);
            ctx.lineTo(x * gridSize + gridSize, y * gridSize + gridSize - radius);
            ctx.arcTo(x * gridSize + gridSize, y * gridSize + gridSize, x * gridSize + gridSize - radius, y * gridSize + gridSize, radius);
            ctx.lineTo(x * gridSize + radius, y * gridSize + gridSize);
            ctx.arcTo(x * gridSize, y * gridSize + gridSize, x * gridSize, y * gridSize + gridSize - radius, radius);
            ctx.lineTo(x * gridSize, y * gridSize + radius);
            ctx.arcTo(x * gridSize, y * gridSize, x * gridSize + radius, y * gridSize, radius);
            ctx.closePath();
            ctx.fill();
        }

        /**
         * Draws the entire snake on the canvas.
         */
        function drawSnake() {
            // Draw the head of the snake with a distinct color
            drawSegment(snake[0].x, snake[0].y, '#4CAF50'); // Green head
            // Draw the body segments
            for (let i = 1; i < snake.length; i++) {
                drawSegment(snake[i].x, snake[i].y, '#38A169'); // Darker green body
            }
        }

        /**
         * Draws the food on the canvas.
         */
        function drawFood() {
            drawSegment(food.x, food.y, '#EF4444'); // Red food
        }

        /**
         * Clears the entire canvas.
         */
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        /**
         * Updates the position of the snake based on its current direction.
         */
        function moveSnake() {
            // Create a new head for the snake based on the current direction
            const head = { x: snake[0].x + dx, y: snake[0].y + dy };

            // Add the new head to the beginning of the snake array
            snake.unshift(head);

            // Check if the snake has eaten the food
            const didEatFood = head.x === food.x && head.y === food.y;

            if (didEatFood) {
                score++; // Increment score
                scoreDisplay.textContent = `Score: ${score}`; // Update score display
                generateFood(); // Generate new food
                // Increase game speed slightly for every 5 points
                if (score % 5 === 0 && gameSpeed > 50) {
                    gameSpeed -= 10; // Decrease interval time to increase speed
                    clearInterval(gameInterval); // Clear existing interval
                    gameInterval = setInterval(gameLoop, gameSpeed); // Set new interval
                }
            } else {
                // If no food was eaten, remove the tail segment
                snake.pop();
            }
        }

        /**
         * Checks for collision with walls or the snake's own body.
         * @returns {boolean} True if a collision occurred, false otherwise.
         */
        function checkCollision() {
            const head = snake[0];

            // Check collision with walls
            const hitLeftWall = head.x < 0;
            const hitRightWall = head.x >= tileCountX;
            const hitTopWall = head.y < 0;
            const hitBottomWall = head.y >= tileCountY;

            if (hitLeftWall || hitRightWall || hitTopWall || hitBottomWall) {
                return true;
            }

            // Check collision with own body
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }
            return false;
        }

        /**
         * The main game loop. Updates game state and redraws the canvas.
         */
        function gameLoop() {
            if (isGameOver) {
                return; // Stop the loop if game is over
            }

            changingDirection = false; // Reset flag after movement

            clearCanvas(); // Clear the canvas for the next frame
            drawFood();    // Draw the food
            moveSnake();   // Move the snake

            if (checkCollision()) {
                isGameOver = true;
                clearInterval(gameInterval); // Stop the game loop
                showGameOverMessage(); // Display game over message
            }

            drawSnake();   // Draw the snake in its new position
        }

        /**
         * Displays the game over message box.
         */
        function showGameOverMessage() {
            messageTitle.textContent = "Game Over!";
            finalScoreDisplay.textContent = score;
            messageText.textContent = `Your final score: ${score}`;
            messageBox.style.display = 'block'; // Show the message box

            // Update high score if current score is higher
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snakeHighScore', highScore); // Save to local storage
                highScoreDisplay.textContent = `High Score: ${highScore}`;
                messageText.textContent = `New High Score! Your score: ${score}`;
            }
        }

        /**
         * Resets all game variables and starts a new game.
         */
        function resetGame() {
            snake = [{ x: 10, y: 10 }];
            dx = 0;
            dy = 0;
            score = 0;
            gameSpeed = 150;
            isGameOver = false;
            changingDirection = false;

            scoreDisplay.textContent = `Score: ${score}`;
            highScoreDisplay.textContent = `High Score: ${highScore}`; // Ensure high score is updated

            generateFood(); // Generate food for the new game
            clearCanvas();
            drawSnake();
            drawFood();

            // Hide the message box
            messageBox.style.display = 'none';

            // Start the game loop
            clearInterval(gameInterval); // Clear any existing interval
            gameInterval = setInterval(gameLoop, gameSpeed);
        }

        /**
         * Handles keyboard input for changing snake direction.
         * @param {KeyboardEvent} event - The keyboard event object.
         */
        function changeDirection(event) {
            // Prevent rapid direction changes within a single game frame
            if (changingDirection) return;
            changingDirection = true;

            const keyPressed = event.keyCode;
            const LEFT_KEY = 37;
            const UP_KEY = 38;
            const RIGHT_KEY = 39;
            const DOWN_KEY = 40;

            const goingUp = dy === -1;
            const goingDown = dy === 1;
            const goingRight = dx === 1;
            const goingLeft = dx === -1;

            if (keyPressed === LEFT_KEY && !goingRight) {
                dx = -1;
                dy = 0;
            } else if (keyPressed === UP_KEY && !goingDown) {
                dx = 0;
                dy = -1;
            } else if (keyPressed === RIGHT_KEY && !goingLeft) {
                dx = 1;
                dy = 0;
            } else if (keyPressed === DOWN_KEY && !goingUp) {
                dx = 0;
                dy = 1;
            }
        }

        /**
         * Handles touch input for changing snake direction.
         * @param {TouchEvent} event - The touch event object.
         */
        function handleTouchStart(event) {
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        }

        /**
         * Handles touch end event to determine swipe direction.
         * @param {TouchEvent} event - The touch event object.
         */
        function handleTouchEnd(event) {
            touchEndX = event.changedTouches[0].clientX;
            touchEndY = event.changedTouches[0].clientY;
            handleSwipe();
        }

        /**
         * Determines the swipe direction and updates snake direction.
         */
        function handleSwipe() {
            if (changingDirection) return;
            changingDirection = true;

            const dxSwipe = touchEndX - touchStartX;
            const dySwipe = touchEndY - touchStartY;

            const goingUp = dy === -1;
            const goingDown = dy === 1;
            const goingRight = dx === 1;
            const goingLeft = dx === -1;

            if (Math.abs(dxSwipe) > Math.abs(dySwipe)) { // Horizontal swipe
                if (dxSwipe > 0 && !goingLeft) { // Swiped right
                    dx = 1;
                    dy = 0;
                } else if (dxSwipe < 0 && !goingRight) { // Swiped left
                    dx = -1;
                    dy = 0;
                }
            } else { // Vertical swipe
                if (dySwipe > 0 && !goingUp) { // Swiped down
                    dx = 0;
                    dy = 1;
                } else if (dySwipe < 0 && !goingDown) { // Swiped up
                    dx = 0;
                    dy = -1;
                }
            }
        }

        // Event Listeners
        document.addEventListener('keydown', changeDirection);
        restartButton.addEventListener('click', resetGame);
        canvas.addEventListener('touchstart', handleTouchStart, false);
        canvas.addEventListener('touchend', handleTouchEnd, false);
        window.addEventListener('resize', initializeCanvasSize); // Adjust canvas on window resize
        window.onload = function() {
            initializeCanvasSize(); // Set initial canvas size
            resetGame(); // Start the game when the page loads
        };
    </script>
</body>
</html>
